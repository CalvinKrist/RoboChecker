mdp

//CONSTANTS
const int w = 10;
const int h = 10;

//Formula for checking if movement along an angle is in bounds
formula moveA0 = ((w-x2 >= 1) & (y2 > 0));
formula moveA1 = ((x2 > 0) & (h-y2 >= 1));
formula moveA2 = ((x2-1 > 0) & (y2 > 0));
formula moveA3 = ((x2 > 0) & (y2-1 > 0));

//Formula for checking if movement along an angle collides with obstacles
formula collideA0 = (x2+1!=ox0 & y2!=oy0);
formula collideA1 = (x2!=ox0 & y2+1!=oy0);
formula collideA2 = (x2-1!=ox0 & y2!=oy0);
formula collideA3 = (x2!=ox0 & y2-1!=oy0);

module random_robot

        x2 : [1..10] init 1; // robot x position
        y2 : [1..10] init 1; // robot y position
        dir : [0..3] init 0; // possible robot directions

        // Movement transitions when robot can move
        [] (dir=0 & moveA0 & collideA0) -> 1 : (x2'=x2+1) & (y2'=y2);
        [] (dir=1 & moveA1 & collideA1) -> 1 : (x2'=x2) & (y2'=y2+1);
        [] (dir=2 & moveA2 & collideA2) -> 1 : (x2'=x2-1) & (y2'=y2);
        [] (dir=3 & moveA3 & collideA3) -> 1 : (x2'=x2) & (y2'=y2-1);

        // Movement transitions when robot can't move
        [] (dir=0 & !moveA0) -> 1 / 4 : (dir'=0) + 1 / 4 : (dir'=1) + 1 / 4 : (dir'=2) + 1 / 4 : (dir'=3);
        [] (dir=1 & !moveA1) -> 1 / 4 : (dir'=0) + 1 / 4 : (dir'=1) + 1 / 4 : (dir'=2) + 1 / 4 : (dir'=3);
        [] (dir=2 & !moveA2) -> 1 / 4 : (dir'=0) + 1 / 4 : (dir'=1) + 1 / 4 : (dir'=2) + 1 / 4 : (dir'=3);
        [] (dir=3 & !moveA3) -> 1 / 4 : (dir'=0) + 1 / 4 : (dir'=1) + 1 / 4 : (dir'=2) + 1 / 4 : (dir'=3);

endmodule
module obstacle0
        ox0 : int init 9;
        oy0 : int init 1;
endmodule